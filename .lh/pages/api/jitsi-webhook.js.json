{
    "sourceFile": "pages/api/jitsi-webhook.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1763000892667,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1763000892667,
            "name": "Commit-0",
            "content": "// pages/api/jitsi-webhook.js\nimport { doc, getDoc, updateDoc } from \"firebase/firestore\";\nimport { db } from \"../../lib/firebase\"; // Ajusta la ruta según tu estructura\n\n// Deshabilitar el body parser predeterminado\nexport const config = {\n  api: {\n    bodyParser: false,\n  },\n};\n\nexport default async function handler(req, res) {\n  if (req.method !== 'POST') {\n    return res.status(405).json({ error: 'Método no permitido' });\n  }\n\n  try {\n    // 1. Verificar la autenticidad del webhook (CRÍTICO EN PRODUCCIÓN)\n    // JaaS firma los eventos con un header 'x-jitsi-signature'.\n    // Debes verificar esta firma con tu API Secret para asegurar que la solicitud\n    // proviene de JaaS y no de un atacante.\n    // Consulta la documentación de JaaS para implementar la verificación del JWT del evento.\n    // Por simplicidad en este ejemplo, se omite, pero es esencial en producción.\n\n    const body = await new Promise((resolve) => {\n      let body = '';\n      req.on('data', chunk => {\n        body += chunk.toString();\n      });\n      req.on('end', () => {\n        resolve(JSON.parse(body));\n      });\n    });\n\n    console.log(\"Webhook recibido\", body);\n\n    const event = body;\n\n    // 2. Extraer información del cuerpo del evento\n    // Asumimos que el evento es de tipo \"recording.status\" y el estado es \"ready\"\n    if (event.eventType === 'recording.status' && event.data.status === 'ready') {\n      const recordingUrl = event.data.location; // La URL de descarga de la grabación\n      const roomName = event.context.roomName; // Nombre de la sala\n\n      // 3. Extraer courseId y lessonId del roomName\n      // Asumiendo el formato: `${courseId}_${jitsiRoom}`\n      const [courseId, jitsiRoom] = roomName.split('_');\n\n      if (!courseId || !jitsiRoom) {\n        console.error(\"No se pudo extraer courseId y jitsiRoom del roomName:\", roomName);\n        return res.status(400).json({ error: 'Formato de roomName inválido' });\n      }\n\n      // 4. Buscar la lección específica en Firestore\n      // Necesitamos encontrar la lección que tiene `content` === `${courseId}_${jitsiRoom}`\n      const courseDocRef = doc(db, \"courses\", courseId);\n      const courseSnap = await getDoc(courseDocRef);\n\n      if (!courseSnap.exists()) {\n        console.error(\"Curso no encontrado:\", courseId);\n        return res.status(404).json({ error: 'Curso no encontrado' });\n      }\n\n      const courseData = courseSnap.data();\n      const lessons = courseData.lessons || [];\n\n      // Buscar la lección que coincide con el roomName\n      const lessonToUpdate = lessons.find(lesson => lesson.content === roomName);\n\n      if (!lessonToUpdate) {\n        console.error(\"Lección no encontrada en el curso con roomName:\", roomName);\n        return res.status(404).json({ error: 'Lección no encontrada en el curso' });\n      }\n\n      // 5. Actualizar solo la lección con la URL de la grabación\n      const updatedLessons = lessons.map(lesson => {\n        if (lesson.id === lessonToUpdate.id) {\n          return {\n            ...lesson,\n            recordingUrl: recordingUrl\n          };\n        }\n        return lesson;\n      });\n\n      // 6. Actualizar el documento del curso en Firestore\n      await updateDoc(courseDocRef, {\n        lessons: updatedLessons\n      });\n\n      console.log(`Grabación guardada exitosamente para la lección ${lessonToUpdate.id} en el curso ${courseId}`);\n      return res.status(200).json({ success: true, message: 'Grabación guardada en Firestore' });\n\n    } else {\n      // No es un evento de grabación listo, ignóralo\n      console.log(\"Evento recibido, pero no es de grabación lista:\", event.eventType);\n      return res.status(200).json({ success: true, message: 'Evento no relevante' });\n    }\n\n  } catch (error) {\n    console.error(\"Error procesando el webhook de Jitsi:\", error);\n    return res.status(500).json({ error: 'Error interno del servidor' });\n  }\n}"
        }
    ]
}